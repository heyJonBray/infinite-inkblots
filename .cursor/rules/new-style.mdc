---
description: 
globs: 
alwaysApply: false
---
# Infinite Inkblots - New Style Integration Guide

This document provides guidelines for implementing new visual styles for the Infinite Inkblots NFT project. It focuses on maintaining deterministic generation from Ethereum addresses while allowing complete flexibility in the visual algorithm used.

## Project Goals

The core goal of Infinite Inkblots is to create unique, visually compelling images that:
1. Are deterministically generated from Ethereum addresses
2. Have consistent quality and aesthetic appeal
3. Maintain uniqueness across the collection
4. Extract meaningful traits that can be used as NFT metadata
5. Are centered within the canvas with appropriate margins

## Architecture Requirements

When implementing a new visual style, maintain these architectural principles:

### 1. Modular Structure

Organize your code into these logical components:
- **Main Generation Module**: Core algorithm for your visual style
- **ETH Integration Module**: Functions to extract and apply Ethereum address features
- **Parameter Handling**: Clean interfaces for configuration
- **Trait Extraction**: Functions to derive metadata from generated images

### 2. Ethereum Address Integration

Regardless of visual style, your implementation must:
- Extract consistent features from Ethereum addresses
- Map these features to visual parameters
- Ensure deterministic output (same address = same image)
- Support the ability to regenerate identical images from the same address

### 3. Function Interfaces

Maintain these key interfaces:
```python
def create_image(
    size=800,
    eth_address=None,
    whitespace_margin=0.15,
    **style_specific_params
):
    """Main image generation function"""
    pass

def extract_eth_features(eth_address):
    """Extract features from an Ethereum address"""
    pass

def apply_eth_features_to_params(base_params, eth_features):
    """Map ETH features to visual parameters"""
    pass

def extract_traits(image, eth_address=None, generation_params=None):
    """Extract metadata traits from a generated image"""
    pass
```

## Required Features for Any Style

### 1. Deterministic Generation

- All random operations must be seeded using a value derived from the ETH address
- The same address must always produce the same image
- Document any operations that could affect determinism

### 2. Parameter Mapping

Map these ETH address features (at minimum) to visual parameters:
- Character distribution (diversity, repeated characters)
- Numerical properties (number of zeros, ones, etc.)
- Hex value distribution (high vs low values)
- Address sections (beginning, ending characters)

### 3. Composition Standards

- Final images should be square (default 800Ã—800px)
- Main visual elements should be centered
- Include configurable whitespace margin
- Support transparent backgrounds
- Ensure sufficient contrast for visibility

### 4. Trait Extraction

Design your algorithm to support extraction of these trait categories:
- Complexity metrics
- Density/sparseness metrics 
- Dominant features
- Pattern classifications
- Rarity indicators

## Implementation Approach

### 1. Start with ETH Utilities

Begin by implementing or reusing these Ethereum utilities:
```python
def normalize_eth_address(address):
    """Normalize an Ethereum address"""
    pass

def eth_address_to_seed(address):
    """Convert an Ethereum address to a deterministic seed"""
    pass

def extract_eth_features(address):
    """Extract features from the address that can influence visuals"""
    pass
```

### 2. Create Parameter Mapping

Implement functions that map ETH features to your specific visual parameters:
```python
def map_eth_to_visual_params(eth_features):
    """Map ETH features to parameters for your visual algorithm"""
    pass
```

### 3. Develop Core Visual Algorithm

Implement your core visual algorithm with:
- Clear parameter interfaces
- Deterministic operation
- Configurable variation
- Performance considerations

### 4. Ensure Proper Composition

Regardless of style, all images should:
- Be properly centered
- Have configurable margins
- Work well in NFT marketplaces

### 5. Add Metadata Extraction

Implement trait extraction that captures the unique properties of your style:
```python
def analyze_image_traits(image, params):
    """Analyze the image and extract distinguishing traits"""
    pass
```

## Forward Compatibility Considerations

### 1. Extensible Parameter System

- Use dictionary-based parameter systems that can be extended
- Document parameter ranges and effects
- Implement parameter validation

### 2. Trait Categorization

- Plan for trait categories that might be added later
- Implement a trait scoring system for rarity calculations
- Support multiple trait extraction methods

### 3. Style Variants

- Design your system to support variants within your style
- Consider parameters that could enable "special" or "rare" generations
- Allow for collections or series within your style

## Testing Guidelines

Implement tests that verify:
1. Deterministic output for the same address
2. Reasonable variation across different addresses
3. Parameter boundaries and effects
4. Performance benchmarks
5. Visual quality assessment

## Documentation Requirements

Document:
1. The conceptual basis of your visual style
2. How ETH features influence the output
3. The full range of possible variations
4. Any special or rare trait combinations
5. Performance characteristics

## NFT Integration Specifics

Ensure your implementation supports:
1. High-resolution output for NFT minting
2. JSON metadata generation in standard formats
3. Preview generation at various scales
4. Trait rarity distributions
5. Collection-wide uniqueness